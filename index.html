<!DOCTYPE html><html><head><title>Team Git</title><!-- deck.js styles--><link rel="stylesheet" href="/teamgit-deck/deck.js/core/deck.core.css"/><link rel="stylesheet" href="/teamgit-deck/deck.js/extensions/goto/deck.goto.css"/><link rel="stylesheet" href="/teamgit-deck/deck.js/extensions/menu/deck.menu.css"/><link rel="stylesheet" href="/teamgit-deck/deck.js/extensions/navigation/deck.navigation.css"/><link rel="stylesheet" href="/teamgit-deck/deck.js/extensions/status/deck.status.css"/><link rel="stylesheet" href="/teamgit-deck/deck.js/extensions/hash/deck.hash.css"/><!-- deck.js themes--><link rel="stylesheet" href="/teamgit-deck/deck.js/themes/style/neon.css"/><link rel="stylesheet" href="/teamgit-deck/deck.js/themes/transition/horizontal-slide.css"/><!-- deck.js custom build of modernizr--><script src="/teamgit-deck/deck.js/modernizr.custom.js"></script></head><body class="deck-container"><section id="title-slide" class="slide"><h1>Team Git</h1></section><section class="slide"><h1>A deep dive into typical git work-flows</h1></section><section class="slide"><h2>It all starts with a clone (git-clone, git-status, objects, deltas)</h2><pre class="slide"><code>$ git clone git@github.com:bramswenson/teamgit.git teamgit
</code></pre><pre class="slide"><code>Cloning into 'teamgit'..."
remote: Counting objects: 1094, done.
remote: Compressing objects: 100% (613/613), done.
remote: Total 1094 (delta 570), reused 820 (delta 398)
Receiving objects: 100% (1094/1094), 347.61 KiB, done.
Resolving deltas: 100% (570/570), done.
</code></pre><pre class="slide"><code>cd teamgit
</code></pre><pre class="slide"><code>$ git status
# On branch master
nothing to commit (working directory clean)
</code></pre><h3 class="slide">Why are we already on the master branch? How does git know thats what we want? What if we want another branch to be defaulted?</h3></section><section class="slide"><h2>HEAD pointer (git-clone, git-branch)</h2><pre class="slide"><code>$ git branch
* master
</code></pre><pre class="slide"><code>$ git branch -a
* master
remotes/origin/HEAD -> origin/master
remotes/origin/master
</code></pre><h3 class="slide">Notice the HEAD pointer in the previous command. This setting is what determines the "default" branch when cloning from a remote repository. For more information check out the "set-head" section of the git-remote man page. This is commonly used by teams that want to the default branch to be something other than "master", such as "development".</h3></section><section class="slide"><h2>Check it out (git-checkout, git-status)</h2><pre class="slide"><code>$ git checkout -b topic_one master
Switched to new branch 'topic_one'
</code></pre><pre class="slide"><code>$ git branch
  master
* topic
</code></pre><pre class="slide"><code>$ vi topic_one.rb
</code></pre><pre class="slide"><code>$ git status
# On branch topic_one
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#       topic_one.rb
nothing added to commit but untracked files present (use "git add" to track)
</code></pre><h3 class="slide">Note that creating git branches can be done with the git-branch or git-checkout commands. git-branch is used more for getting information about and creating branches, while git-checkout is more about switching branches. The `git checkout -b topic_one master` switch tells checkout to create a new local branch called "topic_one" from the existing local branch "master".</h3></section><section class="slide"><h2>Add to the mix (git-add, git-status, git-commit)</h2><pre class="slide"><code>$ git add topic_one.rb
</code></pre><pre class="slide"><code>$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#       new file:   topic_one.rb#
</code></pre><pre class="slide"><code>$ git commit -m 'added topic_one class def'
[master 718c9d4] added topic_one class def
 1 files changed, 2 insertions(+), 0 deletions(-)
 create mode 100644 topic_one.rb
</code></pre><pre class="slide"><code>$ git log --graph --oneline --decorate
* 718c9d4 (HEAD, master) added topic_one class def
* ed3a401 initial commit
</code></pre><h3 class="slide">So now we have modified the repository with new code, and committed that code to the repository with git-add. Looking at the git-log, we can see that this commit is indeed listed in our commit history.</h3></section><section class="slide"><h1>So what is a commit anyway?</h1></section><section class="slide"><h2>Object Oriented Git?</h2><h3 class="slide">The "commit" object links a physical state of a tree with a description of how we got there and why.</h3><h3 class="slide">All the information needed to represent the history of a project is stored in files referenced by a 40 character "object name" that looks something like this:</h3><pre class="slide"><code>ed3a401eb9b70c1f8d7cb88966f66940c68cf47a
</code></pre><h3 class="slide">You will see these 40-character strings all over the place in Git, though they will commonly be referred to as "hashes" or "shas". In each case the name is calculated by taking the SHA1 hash of the contents of the object. The SHA1 hash is a cryptographic hash function. What that means to us is that it is virtually impossible to find two different objects with the same name. This has a number of advantages; among others:</h3><ul><li class="slide"><h3>Git can quickly determine whether two objects are identical or not, just by comparing names.</h3></li><li class="slide"><h3>Since object names are computed the same way in every repository, the same content stored in two repositories will always be stored under the same name.</h3></li><li class="slide"><h3>Git can detect errors when it reads an object, by checking that the object's name is still the SHA1 hash of its contents.</h3></li></ul><h5 class="slide">Taken from http://book.git-scm.com/1_the_git_object_model.html</h5></section><section class="slide"><h2>Ok then, what are these "Objects"?</h2><h3 class="slide">Everything stored in a git repository is stored as a type of git object. Every object consists of three things - a type, a size and content. The size is simply the size of the contents, the contents depend on what type of object it is, and there are four different types of objects: "blob", "tree", "commit", and "tag".</h3><ul><li class="slide"><h3>A "blob" is used to store file data - it is generally a file.</h3></li><li class="slide"><h3>A "tree" is basically like a directory - it references a bunch of other trees and/or blobs (i.e. files and sub-directories)</h3></li><li class="slide"><h3>A "commit" points to a single tree, marking it as what the project looked like at a certain point in time. It contains meta-information about that point in time, such as a timestamp, the author of the changes since the last commit, a pointer to the previous commit(s), etc.</h3></li><li class="slide"><h3>A "tag" is a way to mark a specific commit as special in some way. It is normally used to tag certain commits as specific releases or something along those lines.</h3></li><li class="slide"><h3>Almost all of Git is built around manipulating this simple structure of four different object types. It is sort of its own little filesystem that sits on top of your machine's filesystem.</h3></li></ul><h5 class="slide">Again, taken from http://book.git-scm.com/1_the_git_object_model.html</h5></section><section class="slide"><h2>Different from SVN</h2><h3><p class="slide">It is important to note that this is very different from most SCM systems that you may be familiar with. Subversion, CVS, Perforce, Mercurial and the like all use Delta Storage systems - they store the differences between one commit and the next.</p><p class="slide">Git does not do this - it stores a snapshot of what all the files in your project look like in this tree structure each time you commit.</p><p class="slide">This is a very important concept to understand when using Git.</p></h3></section><section class="slide"><h2>git-log</h2><h3 class="slide">Each time we make a commit to a git repository, a log entry is created. This log entry specifies the SHA 1 hash of the commit as well as the other crucial bits of metadata. We can look at this log to get a visual representation of our commit history. This history is typically sorted by time showing the newest commit first:</h3><pre class="slide"><code>$ git log
commit e5d2d5209aaeb2afbf5d9f86603620052e78c432
Author: Bram Swenson <bswenson@kabam.com>
Date:   Fri Mar 2 09:47:08 2012 -0800
    Added topic_one class
commit ed3a401eb9b70c1f8d7cb88966f66940c68cf47a
Author: Bram Swenson <bswenson@kabam.com>
Date:   Mon Feb 13 08:57:27 2012 -0800
    initial commit
</code></pre><h3 class="slide">git-log will take quite a few optional switches in order to modify the display of the log:</h3><pre class="slide"><code>$ git log --graph --oneline --decorate
* 9a31973 (HEAD, topic_one) added topic_one class
* ed3a401 (origin/master, master) initial commit
</code></pre><h3 class="slide">This view is useful to determine the HEAD states of various local and remote branches.</h3></section><section class="slide"><h1>How to we keep all these repos in sync?</h1></section><section class="slide"><h2>Regular updates with pull and push</h2><pre class="slide"><code>$ git pull origin master
# if merge conflicts, fix them here
$ git push origin topic_one
</code></pre><pre class="slide"><code>$ git checkout master
$ git pull origin master
$ git merge topic_one
$ git push origin master
</code></pre><pre class="slide"><code>$ git log --graph --oneline --decorate
* 57db91c (HEAD, origin/topic_one, origin/master, topic_one, master) added topic_one.rb
* ed3a401 initial commit
</code></pre><pre class="slide"><code>$ git branch -a
* master
  topic_one
  remotes/origin/master
  remotes/origin/topic_one
</code></pre></section><section class="slide"><h2>Knowing Our Origins</h2><h3 class="slide">One typically starts their first endeavour with a code base by cloning it from a centralized server. In git speak, this server is know as a remote. The git-clone command automatically adds this remote with a name of origin. Git allows for more than one remote repository, known as forks, which we will dissect a bit later.</h3><h3 class="slide">There are various ways to explore your remote configuration with git-remote.</h3><pre class="slide"><code>$ git clone git@github.com:bramswenson/teamgit.git teamgit
$ cd teamgit
</code></pre><pre class="slide"><code>$ git remote
origin
</code></pre><pre class="slide"><code>$ git remote -v
origin  git@github.com:bramswenson/teamgit.git (fetch)
origin  git@github.com:bramswenson/teamgit.git (push)
</code></pre><pre class="slide"><code>$ git push
# this is shorthand for
$ git push origin CURRENT_BRANCH
</code></pre><h3 class="slide">Generally speaking, it may be best to avoid most git shorthand notations. Using the full command syntax helps to ensure your are explicitly performing the function that you desire. It also helps to drive home the concepts behind git usage.</h3></section><section class="slide"><h2>Forking is implicit</h2><h3 class="slide">Forking is one of the most powerful features of git that you may never use. If you collaborate on open source projects however, you will almost certainly use forks. In fact it is so common to use forks on open source projects we will use this context for our example.</h3><h3 class="slide">Say we want to add some awesome new feature to rails. Since we do not have commit permissions to the rails core code base, we will need a fork. In github.com there is a button for just this function.  However we will learn how to do this manually, without fancy web interfaces. Fortunately this actually pretty easy.</h3></section><section class="slide"><h2>Forking is implicit (cont.)</h2><ul><li class="slide"><h3>First we clone the repository we want to fork</h3><pre><code>$ git clone git@github.com/rails/rails.git
$ cd rails
</code></pre></li><li class="slide"><h3>Just with any other time we clone, the origin remote is automatically set to the url from which we clone.</h3><pre><code>$ git remote -v
origin  git@github.com:rails/rails.git (fetch)
origin  git@github.com:rails/rails.git (push)
</code></pre></li><li class="slide"><h3>We want to replace origin with another url, but we want to occasionally synchronize our fork with the upstream fork from the rails team. In order to make this possible we will simply rename our existing remote from the default name `origin` to our arbitrarily selected name `rails_upstream`.</h3><pre><code>$ git remote rename origin rails_upstream
$ git remote -v
rails_upstream  git@github.com:rails/rails.git (fetch)
rails_upstream  git@github.com:rails/rails.git (push)
</code></pre></li></ul></section><section class="slide"><h2>Forking is implicit (cont.)</h2><ul><li class="slide"><h3>Now we want to replace the default remote, origin, with our own url.</h3><pre><code>$ git remote add origin git@github.com:bramswenson/rails.git
$ git remote -v
origin  git@github.com:bramswenson/rails.git (fetch)
origin  git@github.com:rails/bramswenson.git (push)
rails_upstream  git@github.com:rails/rails.git (fetch)
rails_upstream  git@github.com:rails/rails.git (push)
</code></pre></li><li class="slide"><h3>The important thing to note here is that we now have 2 possible remotes to pull/push from/to. This is a critical point to understand about git, and is at the very core of its distributed nature.</h3><pre><code># This would pull from the origin: git@github.com:bramswenson/rails.git
$ git pull origin master
# While this would pull from the origin: git@github.com:rails/rails.git
$ git pull rails_upstream master
</code></pre></li></ul></section><section class="slide"><h2>Pull is nothing but a shortcut</h2><h3 class="slide">If you have used git at all, you have used git pull. What you may not have known is that it is a simply a shorthand command, basically to save typing. Here is the first line of the description in the git-pull man page:</h3><blockquote class="slide"><p>Incorporates changes from a remote repository into the current branch. In its default mode, git pull is shorthand for git fetch followed by git merge FETCH_HEAD. More precisely, git pull runs git fetch with the given parameters and calls git merge to merge the retrieved branch heads into the current branch.</p></blockquote></section><section class="slide"><h2>Pull is nothing but a shortcut (cont.)</h2><h3 class="slide">Ah Ha...So the following command sets are basically identical:</h3><pre class="slide"><code>$ git pull origin master
# is exactly the same as
</code></pre><pre class="slide"><code>$ git fetch origin && git merge FETCH_HEAD
# which also can be translated to
</code></pre><pre class="slide"><code>$ git fetch origin && git merge origin/master
</code></pre></section><section class="slide"><h2>Pull is nothing but a shortcut (cont.)</h2><h3 class="slide">In fact it goes even deeper, given that with just a single flag the behavior of git pull radically changes. Again from the git-pull man page under the section describing `git pull --rebase`:</h3><blockquote class="slide"><p>With --rebase, it runs git rebase instead of git merge.</p></blockquote><h3 class="slide">Whoa there..</h3><h3 class="slide">Thats a pretty big difference to cover in a single switch.</h3><h3 class="slide">But wait rebase is evil...The web says so all over the place.</h3></section><section class="slide"><h1>Actually no, rebase is not evil.</h1></section><section class="slide"><h2>Pull is nothing but a shortcut (cont.)</h2><h3 class="slide">Really git-rebase is a very powerful command. As with any great power, there also comes with great responsibility. The man page for git-pull gives us pretty clear advice warning about danger, but no talk of evil:</h3><blockquote class="slide"><p>This is a potentially dangerous mode of operation. It rewrites history, which does not bode well when you published that history already. Do not use this option unless you have read git-rebase(1) carefully or your team has been given this demo by Bram.</p></blockquote><h3 class="slide">No really, it says that!</h3></section><section class="slide"><h1>All your rebase are belong to us!</h1></section><section class="slide"><h1><img src="http://www.halolz.com/wp-content/uploads/2007/10/allyourbasekitty.gif"/></h1></section><section class="slide"><h2>All your rebase are belong to us!</h2><h3 class="slide">So why all the fuss about rebase? Simply put, because it <strong>rewrites commit history</strong>. Diving once more into the trusty git man pages, this time for git-rebase:</h3><blockquote class="slide">git-rebase Forward-port local commits to the updated upstream head</blockquote><h3 class="slide">Foward-port eh? What git does in plain english is the following:</h3><ol><li class="slide">Compares the upstream commit history and your local commit history from the newest to the oldest commits.</li><li class="slide">This comparison is complete when git finds the first common historical commit in both the local and remote repositories.</li><li class="slide">Git then rewinds all the commits from the local repository that have been made since the common commit.</li><li class="slide">Next git applies all of the commits from the upstream repository since the common commit to the local repository.</li><li class="slide">Now each of the rewound local commits is reapplied to the updated local repository.</li><li class="slide">If no conflicts exist the next commit is reapplied, and this process repeats for until there are no more local commits to reapply.</li><li class="slide">If conflicts exists, the rebase will pause to allow the conflict to be resolved manually, like any other merge conflict.</li><li class="slide">Once the conflicts have been resolved and the updated files have been added, `git rebase --continue` is issued and the rebase continues.</li><li class="slide">When no more commits need to be applied and all conflicts have been resolved, the rebase is complete.</li></ol></section><section class="slide"><h2>All your rebase are belong to us! (cont.)</h2><h3 class="slide">The rebase style of pull has a few advantages when used properly.</h3><h3 class="slide">First, it ensures that the commits in your topic branches are always applied to the end of your commit history, rather than mixed in with upstream commits. This means that when your topic branches are merged into the upstream branches, the commits for the topic are grouped together. Conversely, when one uses a merge based pull, the commits in the local topic branch are weaved into the history in chronological order rather than chronological and topical. The best way to understand this is to look at it in action.</h3></section><section class="slide"><h2>All your rebase are belong to us! (cont.)</h2><h6>`git pull --rebase vs git pull` in terminal</h6></section><section class="slide"><h2>All your rebase are belong to us! (cont.)</h2><h3 class="slide">Pretty much anywhere you read about rebase it will tell you that you shouldn't rebase code you have pushed to remote repositories.</h3><h3 class="slide">This is <strong>bullshit</strong>!</h3><h3 class="slide">If you understand what you are doing with git and so do the other members of your team, its is perfectly acceptable and even common to push rebased branches upstream.</h3></section><section class="slide"><h2>All your rebase are belong to us! (cont.)</h2><h6>`git push origin topic_one -f` in terminal</h6></section><section class="slide"><h2>All your rebase are belong to us! (cont.)</h2><h3 class="slide">Another advantage comes when dealing with conflicts. In a merge based pull, the possibility of merge conflicts exists as well. The primary difference is that the conflicts may be related to code you have not modified in your local topic branch. This means you have no current context of the merge conflicts you are attempting to resolve. However, when using rebase, since all of the upstream changes are applied prior to your local changes, the conflicts are <strong>always related to code within your topic branch</strong>. This is a pretty significant difference and typically means that developers can resolve merge conflicts without the help of other developers when using rebase.</h3></section><section class="slide"><h2>All your rebase are belong to us! (cont.)</h2><h3 class="slide">Another common use of the rebase command is to intentionally rewrite ones git commit history. This can be very useful in topic branches with many minor or exploratory commits.</h3></section><section class="slide"><h2>All your rebase are belong to us! (cont.)</h2><h6>`git rebase -i` in terminal</h6></section><section class="slide"><h2>All your rebase are belong to us! (cont.)</h2><h3 class="slide">So when is it appropriate to use rebase given its dangerous nature? In my opinion there are a few really good use cases for rebase.</h3><ol><li class="slide"><h3>Always use the --rebase flag with git-pull. One can make this the default instead of merge with git-config (see resources link).</h3></li><li class="slide"><h3>Rebase long running topic branches against themselves to squash commits (more on this later) prior to git-pull to reduce merge conflicts.</h3></li><li class="slide"><h3>Rebase all topic branches against themselves before merging them into upstream branches and deleting.</h3></li></ol></section><section class="slide"><h2>Resources and Credits</h2><ul><li><h3><a href="http://progit.org/">ProGit by Scott Chacon</a></h3></li><li><h3><a href="http://darwinweb.net/articles/the-case-for-git-rebase">The Case for Rebase</a></h3></li><li><h3><a href="http://book.git-scm.com/">The Git Community Book</a></h3></li><li><h3><a href="http://help.github.com/">Github Help Pages</a></h3></li><li><h3><a href="http://gitref.org/">GitRef</a></h3></li><li><h3><a href="http://blog.aplikacja.info/2010/11/git-pull-rebase-by-default/">Rebase by default (you should do this)</a></h3></li></ul></section><script src="/teamgit-deck/deck.js/jquery-1.7.min.js"></script><script src="/teamgit-deck/deck.js/core/deck.core.js"></script><script src="/teamgit-deck/deck.js/extensions/hash/deck.hash.js"></script><script src="/teamgit-deck/deck.js/extensions/menu/deck.menu.js"></script><script src="/teamgit-deck/deck.js/extensions/goto/deck.goto.js"></script><script src="/teamgit-deck/deck.js/extensions/status/deck.status.js"></script><script src="/teamgit-deck/deck.js/extensions/navigation/deck.navigation.js"></script><script>$(function() {
  $.deck('.slide');
});
</script></body></html>
